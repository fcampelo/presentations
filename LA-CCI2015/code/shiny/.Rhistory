hjust = 0)
probpars <- list(name  = "sphere",
xmin = rep(0, 10),
xmax = rep(1, 10))
stopcrit <- list(names = "stop_stat", Rnorm = 1.5, sig.level = 0.05)
seed     <- 99
out 	   <- run_ES(lambda, sigma, probpars, stopcrit, seed)
p <- ggplot(data = data.frame(t = seq_along(out$fhist),
f = out$fhist),
aes(x = t, y = f)) +
geom_line() + geom_point() +
ggtitle("Algorithm progress") +
xlab("Iteration") + ylab ("Function value") +
theme(axis.title = element_text(size = 16),
axis.text  = element_text(size = 14),
plot.title = element_text(size = 18))
p + annotate("text",
x = 0.8*out$iter, y = out$fhist[1],
label = paste("Final value:", signif(out$f,6),
"\nTotal iters:", out$iter),
hjust = 0)
probpars <- list(name  = "sphere",
xmin = rep(-2, 10),
xmax = rep(1, 10))
out 	   <- run_ES(lambda, sigma, probpars, stopcrit, seed)
library(ggplot2)
p <- ggplot(data = data.frame(t = seq_along(out$fhist),
f = out$fhist),
aes(x = t, y = f)) +
geom_line() + geom_point() +
ggtitle("Algorithm progress") +
xlab("Iteration") + ylab ("Function value") +
theme(axis.title = element_text(size = 16),
axis.text  = element_text(size = 14),
plot.title = element_text(size = 18))
p + annotate("text",
x = 0.8*out$iter, y = out$fhist[1],
label = paste("Final value:", signif(out$f,6),
"\nTotal iters:", out$iter),
hjust = 0)
library(shiny)
?downloadButton
??Button
shiny::runApp('shiny')
shiny::runApp('shiny')
?"markdownToHTML"
ls(0)
ls()
dir()
cd shiny
setwd("~/Dropbox/000_Meus Trabalhos/UFMG/2015/Conferences and Events/LA-CCI/Paper - Towards Statistical Convergence Criteria for Mutation-Based Evolutionary Algorithms/code/shiny")
markdownToHTML("README.md")
markdownToHTML("README.md")
getwd()
markdownToHTML("README.md", "README.html")
shiny::runApp()
markdownToHTML("README.md2", "README.html")
shiny::runApp()
markdownToHTML("README.md2", "README.html")
shiny::runApp()
markdownToHTML("README.md2", "README.html")
shiny::runApp()
shiny::runApp('~/00_Github/Design-and-Analysis-of-Experiments/Demo01-CLT')
?tableOutput
?plotOutput
?textOutput
shiny::runApp()
shiny::runApp()
shiny::runApp()
# Implements stop criteria for Evolution Strategies
# This routine accesses the calling environment, which means that changes made
# in the variables contained in \code{env} WILL change the original values.
# DO NOT change anything in \code{env} unless you're absolutely sure of what
# you're doing.
check_stop_criteria <- function(){
# Get calling environment
env 			<- parent.frame()
crits 		<- env$stopcrit$names
keep.running 	<- 1
for (crit in crits){
keep.running <- keep.running * !(do.call(crit,
args = list()))
}
return(as.logical(keep.running))
}
# Stop criterion: maximum number of iterations
stop_maxiter <- function(){
env <- parent.frame(n = 2)
return(env$t >= env$stopcrit$maxiter)
}
# Stop criterion: maximum number of objective function calls
stop_maxeval <- function(){
env <- parent.frame(n = 2)
return(env$nfe >= env$stopcrit$maxevals)
}
# Stop criterion: statistical test of convergence to epsilon-neighborhood of
# (local) optimum.
# Rnorm is the desired R/sigma ("normalized R") distance to the optimum
stop_stat <- function(){
env <- parent.frame(n = 2)
stopifnot(all(c("Rnorm", "sig.level") %in% names(env$stopcrit)),
is.numeric(env$stopcrit$Rnorm),
env$stopcrit$Rnorm > 0,
is.numeric(env$stopcrit$sig.level),
env$stopcrit$sig.level > 0 && env$stopcrit$sig.level < 1)
# Probability of successful mutation if the current point is distant from
# the optimum of a (locally-) spherical function by R (=Rnorm*sigma)
# Calculate once and store in the main environment of run_ES
if (!any("mstar" == names(env))) {
env$mstar <- calc_mstar(alpha  = env$stopcrit$sig.level,
Rnorm  = env$stopcrit$Rnorm,
n      = env$n,
lambda = env$lambda)
}
# Echo current state to the console
if(env$no.improv == 0){
cat("\nIteration ", env$t, ":",
env$no.improv, "/", env$mstar, " without improvement.")}
# Evaluate and return stop criterion
return(env$no.improv >= env$mstar)
}
calc_mstar <- function(alpha, Rnorm, n, lambda){
ps <- calc_ps(n, 1, Rnorm)
if (lambda == 1){
return(ceiling(log(alpha / 2) / log(1 - ps)))
} else {
za 	<- qnorm(alpha)
a  	<- (2 * ps / za) ^ 2
b     <- 4 * ps * (3 * ps - 1)
c 	<- - (za ^ 2) * (8 * ps + 1)
d 	<- 4 * ps * (za ^ 2) * (3 * ps + (za ^ 2) * (ps - 1))
return(ceiling(max(Re(polyroot(c(d, c, b, a))))))
}
}
lambda   <- 1
sigma    <- 0.05
probpars <- list(name  = "sphere",
xmin = rep(-2, 10),
xmax = rep(1, 10))
stopcrit <- list(names = "stop_stat", Rnorm = 1.5, sig.level = 0.05)
seed     <- 99
out 	   <- run_ES(lambda, sigma, probpars, stopcrit, seed)
# Implements stop criteria for Evolution Strategies
# This routine accesses the calling environment, which means that changes made
# in the variables contained in \code{env} WILL change the original values.
# DO NOT change anything in \code{env} unless you're absolutely sure of what
# you're doing.
check_stop_criteria <- function(){
# Get calling environment
env 			<- parent.frame()
crits 		<- env$stopcrit$names
keep.running 	<- 1
for (crit in crits){
keep.running <- keep.running * !(do.call(crit,
args = list()))
}
return(as.logical(keep.running))
}
# Stop criterion: maximum number of iterations
stop_maxiter <- function(){
env <- parent.frame(n = 2)
return(env$t >= env$stopcrit$maxiter)
}
# Stop criterion: maximum number of objective function calls
stop_maxeval <- function(){
env <- parent.frame(n = 2)
return(env$nfe >= env$stopcrit$maxevals)
}
# Stop criterion: statistical test of convergence to epsilon-neighborhood of
# (local) optimum.
# Rnorm is the desired R/sigma ("normalized R") distance to the optimum
stop_stat <- function(){
env <- parent.frame(n = 2)
stopifnot(all(c("Rnorm", "sig.level") %in% names(env$stopcrit)),
is.numeric(env$stopcrit$Rnorm),
env$stopcrit$Rnorm > 0,
is.numeric(env$stopcrit$sig.level),
env$stopcrit$sig.level > 0 && env$stopcrit$sig.level < 1)
# Probability of successful mutation if the current point is distant from
# the optimum of a (locally-) spherical function by R (=Rnorm*sigma)
# Calculate once and store in the main environment of run_ES
if (!any("mstar" == names(env))) {
env$mstar <- calc_mstar(alpha  = env$stopcrit$sig.level,
Rnorm  = env$stopcrit$Rnorm,
n      = env$n,
lambda = env$lambda)
}
# Echo current state to the console
if(env$no.improv == 0){
if(!any("mstar" == names(env))){
env$last.improv <- 0
}
stabspan <- env$t - env$last.improv
env$last.improv <- env$t
cat("\nIteration ", env$t - 1, ":",
stabspan, "/", env$mstar, " without improvement.")}
# Evaluate and return stop criterion
return(env$no.improv >= env$mstar)
}
calc_mstar <- function(alpha, Rnorm, n, lambda){
ps <- calc_ps(n, 1, Rnorm)
if (lambda == 1){
return(ceiling(log(alpha / 2) / log(1 - ps)))
} else {
za 	<- qnorm(alpha)
a  	<- (2 * ps / za) ^ 2
b     <- 4 * ps * (3 * ps - 1)
c 	<- - (za ^ 2) * (8 * ps + 1)
d 	<- 4 * ps * (za ^ 2) * (3 * ps + (za ^ 2) * (ps - 1))
return(ceiling(max(Re(polyroot(c(d, c, b, a))))))
}
}
out 	   <- run_ES(lambda, sigma, probpars, stopcrit, seed)
# Implements stop criteria for Evolution Strategies
# This routine accesses the calling environment, which means that changes made
# in the variables contained in \code{env} WILL change the original values.
# DO NOT change anything in \code{env} unless you're absolutely sure of what
# you're doing.
check_stop_criteria <- function(){
# Get calling environment
env 			<- parent.frame()
crits 		<- env$stopcrit$names
keep.running 	<- 1
for (crit in crits){
keep.running <- keep.running * !(do.call(crit,
args = list()))
}
return(as.logical(keep.running))
}
# Stop criterion: maximum number of iterations
stop_maxiter <- function(){
env <- parent.frame(n = 2)
return(env$t >= env$stopcrit$maxiter)
}
# Stop criterion: maximum number of objective function calls
stop_maxeval <- function(){
env <- parent.frame(n = 2)
return(env$nfe >= env$stopcrit$maxevals)
}
# Stop criterion: statistical test of convergence to epsilon-neighborhood of
# (local) optimum.
# Rnorm is the desired R/sigma ("normalized R") distance to the optimum
stop_stat <- function(){
env <- parent.frame(n = 2)
stopifnot(all(c("Rnorm", "sig.level") %in% names(env$stopcrit)),
is.numeric(env$stopcrit$Rnorm),
env$stopcrit$Rnorm > 0,
is.numeric(env$stopcrit$sig.level),
env$stopcrit$sig.level > 0 && env$stopcrit$sig.level < 1)
# Probability of successful mutation if the current point is distant from
# the optimum of a (locally-) spherical function by R (=Rnorm*sigma)
# Calculate once and store in the main environment of run_ES
if (!any("mstar" == names(env))) {
env$mstar <- calc_mstar(alpha  = env$stopcrit$sig.level,
Rnorm  = env$stopcrit$Rnorm,
n      = env$n,
lambda = env$lambda)
}
# Echo current state to the console
if(env$no.improv == 0){
if(!any("mstar" == names(env))){
env$last.improv <- 0
}
env$stabspan <- env$t - env$last.improv
env$last.improv <- env$t
cat("\nIteration ", env$t - 1, ":",
env$stabspan, "/", env$mstar, " without improvement.")}
# Evaluate and return stop criterion
return(env$no.improv >= env$mstar)
}
calc_mstar <- function(alpha, Rnorm, n, lambda){
ps <- calc_ps(n, 1, Rnorm)
if (lambda == 1){
return(ceiling(log(alpha / 2) / log(1 - ps)))
} else {
za 	<- qnorm(alpha)
a  	<- (2 * ps / za) ^ 2
b     <- 4 * ps * (3 * ps - 1)
c 	<- - (za ^ 2) * (8 * ps + 1)
d 	<- 4 * ps * (za ^ 2) * (3 * ps + (za ^ 2) * (ps - 1))
return(ceiling(max(Re(polyroot(c(d, c, b, a))))))
}
}
out 	   <- run_ES(lambda, sigma, probpars, stopcrit, seed)
lambda   <- 1
sigma    <- 0.05
probpars <- list(name  = "sphere",
xmin = rep(-2, 10),
xmax = rep(1, 10))
stopcrit <- list(names = "stop_stat", Rnorm = 1, sig.level = 0.05)
seed     <- 99
out 	   <- run_ES(lambda, sigma, probpars, stopcrit, seed)
library(ggplot2)
p <- ggplot(data = data.frame(t = seq_along(out$fhist),
f = out$fhist),
aes(x = t, y = f)) +
geom_line() + geom_point() +
ggtitle("Algorithm progress") +
xlab("Iteration") + ylab ("Function value") +
theme(axis.title = element_text(size = 16),
axis.text  = element_text(size = 14),
plot.title = element_text(size = 18))
p + annotate("text",
x = 0.8*out$iter, y = out$fhist[1],
label = paste("Final value:", signif(out$f,6),
"\nTotal iters:", out$iter),
hjust = 0)
out$iter
lambda
out 	   <- run_ES(lambda, sigma, probpars, stopcrit, seed)
p <- ggplot(data = data.frame(t = seq_along(out$fhist),
f = out$fhist),
aes(x = t, y = f)) +
geom_line() + geom_point() +
ggtitle("Algorithm progress") +
xlab("Iteration") + ylab ("Function value") +
theme(axis.title = element_text(size = 16),
axis.text  = element_text(size = 14),
plot.title = element_text(size = 18))
p + annotate("text",
x = 0.8*out$iter, y = out$fhist[1],
label = paste("Final value:", signif(out$f,6),
"\nTotal iters:", out$iter),
hjust = 0)
p + annotate("text",
x = 0.1*out$iter, y = out$fhist[1],
label = paste("Final value:", signif(out$f,6),
"\nTotal iters:", out$iter),
hjust = 0) +
scale_x_log10()
shiny::runApp()
shiny::runApp()
shiny::runApp()
# Simple (1+lambda)-ES
# WARNING:  all operations are performed with all variables standardized to the
# 		interval [0, 1]. Adjust sigma accordingly.
run_ES <- function(lambda, sigma, probpars, stopcrit, seed = NULL){
# ===== Error catching
stopifnot(
is.numeric(lambda),
lambda == floor(lambda),
lambda > 0,
is.numeric(sigma) && sigma > 0,
all(c("name", "xmin", "xmax") %in% names(probpars)),
length(probpars$xmin) == length(probpars$xmax),
length(probpars$xmin) > 0,
is.numeric(c(probpars$xmin, probpars$xmax)),
all(probpars$xmin < probpars$xmax),
is.null(seed) || (is.numeric(seed) && seed > 0 && seed == floor(seed)))
if(is.null(seed))  seed  <- as.numeric(Sys.time())
# ===== Initialize algorithm
set.seed(seed)				# Set PRNG
n   <- length(probpars$xmin)		# problem dimension
t   <- 0      				# iterations counter
x   <- runif(n)				# initialize random candidate solution
f   <- evaluate_point(probpars, x)	# evaluate x
nfe <- 1 					# function evaluations counter
keep.running <- TRUE 			# iteration control flag
no.improv    <- 0 			# lack of improvement counter
lhist    <- 1000
fhist    <- numeric(lhist)			# initialize history vector
fhist[1] <- f
# ===== Iterative cycle
while(keep.running){
# Generate trial vectors
Xc <- matrix(x,
nrow = lambda,
ncol = n,
byrow = TRUE) +
matrix(rnorm(n * lambda,
mean = 0,
sd = sigma),
ncol = n,
nrow = lambda)
# Truncate to limits
Xc <- pmax(0*Xc, pmin(0*Xc + 1, Xc))
# evaluate trial vectors
fc <- evaluate_population(probpars, Xc)
nfe <- nfe + lambda
# Selection
if (any(fc <= f)){
f <- min(fc)
x <- Xc[which.min(fc), ]
no.improv <- 0
} else{
no.improv <- no.improv + 1
}
# Update iteration counter
t <- t + 1
# Update history vector
fhist[t + 1] <- f
# Preallocate more space if needed for fhist
if(t + 1 == lhist){
fhist <- c(fhist, numeric(lhist))
lhist <- 2*lhist
}
# Check stop criteria
keep.running <- check_stop_criteria()
}
cat("/n Optimization finished at iteration ", t)
# Return output
return(list(x     = probpars$xmin + x * (probpars$xmax - probpars$xmin),
f     = f,
fhist = fhist[1:(t+1)],
nfe   = nfe,
iter  = t))
}
shiny::runApp()
p <- ggplot(data = data.frame(t = seq_along(out$fhist),
f = out$fhist),
aes(x = t, y = f)) +
geom_line() + geom_point() +
ggtitle("Algorithm progress") +
xlab("Iteration") + ylab ("Function value") +
theme(axis.title = element_text(size = 16),
axis.text  = element_text(size = 14),
plot.title = element_text(size = 18)) +
annotate("text",
x = 0.1*out$iter, y = out$fhist[1],
label = paste("Final value:", signif(out$f,6),
"\nTotal iters:", out$iter),
hjust = 0) +
scale_x_log10()
print(p)
shiny::runApp()
?renderPrint
a <- renderPrint(out <- run_ES(lambda, sigma, probpars, stopcrit, seed))
a
a()
app <- shinyApp(
ui = fluidPage(
fluidRow(  actionButton("go", "Go!") ),
fluidRow(htmlOutput("html")),
fluidRow(plotOutput('plot'))
),
server = function(input, output) {
theText <- reactiveValues(htmlVar = NULL)
observe({
input$go
isolate({
for (i in 1:5){
theText$htmlVar <- HTML("some text to be displayed")
cat(i) # outputs to the console, just for debugging
Sys.sleep(.1) # pause for 100ms
}
})
})
myPlot <- reactive({input$go
print("setting myPlot")
return (hist(runif(15)))
})
output$html <- renderUI({ theText$htmlVar })
output$plot <- renderPlot({ return (myPlot()) }) # This displays a graph after the loop terminates
})
runApp(app)
?renderPrint
shiny::runApp()
shiny::runApp()
?column
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?reactive
shiny::runApp()
shiny::runApp()
?observeEvent
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?plotOutput
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?plotOutput
shiny::runApp()
rm(list=ls())
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?plotOutput
shiny::runApp()
shiny::runApp()
getwd()
markdown::markdownToHTML("README.md2","README.html")
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?renderText
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?fluidrow
?fluidRow
shiny::runApp()
